Chunked transfers are used when dynamic data are sent over [Persistent Connections](Persistent%20Connections). In the case of dynamic data (e.g. data that's generated by a function on the server, or data fetched by the server from an external API, or data generated continously like in a livestream) the server doesn't know how long the data are going to be when it starts sending it, thus [Pipelining](Pipelining.md) cannot be used. The server could wait for to have all the data and then send them with `Content-Length` header, like in Pipelining, but that would increase latency and in some cases (like live streaming), wouldn't be even possible. 

Instead, the server can send data chunk-by-chunk with each chunk coming with clear delimiters (`\r\n`) and chunk size. After last chunk is sent, an empty chunk (`0\r\n\r\n`) is sent:
```
HTTP/1.1 200 OK
Transfer-Encoding: chunked
Content-Type: video/mp4

5\r\n
data2\r\n
6\r\n
chunk2\r\n
0\r\n
\r\n
```

NB:
- even if the body contains data which look like a chunk header this doesn't mess anything up - it'll be recognised to be part of data and not a header thanks to previous header size. For instance, data `Hello,0\r\n\r\nWorld` contains a string that looks like the last chunk header. However, the client won't be deceived because the response will be chunked like this:
```
HTTP/1.1 200 OK
Transfer-Encoding: chunked
Content-Type: text/plain

5\r\n
Hello\r\n
10\r\n ðŸ‘ˆ
,0/r/n/r/nWorld\r\n
0\r\n
\r\n
```

The header of the problematic chunk is enough to tell the client that the 10 bytes that follow are part of the data and not one more header.

- For a one hour stream, the chunks will be send over one hour, but they will still count as one HTTP request. 